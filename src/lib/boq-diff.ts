/**
 * BOQ Diff Engine — compares an uploaded BOQ (Mapa de Quantidades) against
 * a generated WBS and identifies gaps, surpluses, and quantity mismatches.
 *
 * The engine bridges the xlsx-parser (uploaded BOQ) with findings-to-wbs
 * and project-extrapolator (generated WBS), producing a structured diff
 * that helps users understand what is missing, extra, or mismatched.
 *
 * Matching strategy:
 *   1. Code match (exact or prefix)
 *   2. Description similarity (Portuguese fuzzy matching with Jaccard)
 *   3. Unit compatibility (m2/m², Ud/un, vg/verba, m3/m³)
 *   4. Chapter mapping (ProNIC chapter codes to narrow scope)
 */

import type { BoqItem, ParsedBoq } from "./xlsx-parser";
import type { WbsArticle } from "./wbs-types";
import {
  normalizeText,
  tokenize,
  jaccardSimilarity,
  domainOverlapBonus,
  normalizeUnit,
  unitsCompatible,
  removeAccents,
} from "./text-similarity";

// ============================================================
// Types
// ============================================================

export type DiffStatus =
  | "matched"           // Found in both BOQ and WBS
  | "quantity_mismatch" // Same item, different quantities
  | "missing_in_boq"   // In WBS but not in uploaded BOQ
  | "missing_in_wbs"   // In uploaded BOQ but not in WBS (extra items)
  | "unit_mismatch"    // Same item but different measurement units
  | "new_required";    // Generated by analysis findings, must be added

export interface DiffItem {
  status: DiffStatus;
  /** Description for display */
  description: string;
  /** BOQ article (if exists) */
  boqItem?: BoqItem;
  /** WBS article (if exists) */
  wbsArticle?: WbsArticle;
  /** Quantity delta (positive = WBS needs more, negative = BOQ has more) */
  quantityDelta?: number;
  /** Cost impact of the difference (EUR) */
  costImpact?: number;
  /** Match confidence (0-1) */
  matchConfidence: number;
  /** Recommendation in Portuguese */
  recommendation: string;
  /** Whether this is from a regulation finding (vs extrapolation) */
  isRegulatoryRequired: boolean;
}

export interface BoqDiffResult {
  /** All diff items */
  items: DiffItem[];
  /** Items missing from the uploaded BOQ (need to be added) */
  missingInBoq: DiffItem[];
  /** Items in BOQ but not required by analysis */
  extraInBoq: DiffItem[];
  /** Items with quantity mismatches */
  quantityMismatches: DiffItem[];
  /** Matched items */
  matched: DiffItem[];
  /** Summary */
  summary: {
    totalBoqItems: number;
    totalWbsItems: number;
    matchedCount: number;
    missingCount: number;
    extraCount: number;
    mismatchCount: number;
    /** Cost of missing items (what needs to be added to budget) */
    missingCostEstimate: number;
    /** Total BOQ cost */
    boqTotalCost: number;
    /** Estimated complete project cost */
    estimatedTotalCost: number;
    /** Completeness percentage */
    completenessPercent: number;
  };
  /** Whether the BOQ uses ISO 12006-2 WBS */
  boqUsesIsoWbs: boolean;
  /** Warnings */
  warnings: string[];
}

// ============================================================
// Re-export text utilities (imported from text-similarity.ts)
// textSimilarity, normalizeText, tokenize, jaccardSimilarity,
// domainOverlapBonus, normalizeUnit, unitsCompatible, removeAccents
// ============================================================

/**
 * Compute overall text similarity between two Portuguese construction descriptions.
 * Combines Jaccard similarity with domain keyword overlap bonus.
 */
function textSimilarity(textA: string, textB: string): number {
  const tokensA = tokenize(textA);
  const tokensB = tokenize(textB);

  if (tokensA.size === 0 || tokensB.size === 0) return 0;

  const jaccard = jaccardSimilarity(tokensA, tokensB);
  const bonus = domainOverlapBonus(tokensA, tokensB);

  return Math.min(1, jaccard + bonus);
}

// ============================================================
// Chapter Mapping
// ============================================================

/**
 * Extract the ProNIC chapter prefix from a code (e.g., "06.01.003" -> "06").
 */
function extractChapterCode(code: string): string | null {
  const match = code.match(/^(\d{1,2})/);
  return match ? match[1].padStart(2, "0") : null;
}

/**
 * Check whether two codes share the same ProNIC chapter prefix.
 */
function sameChapter(codeA: string, codeB: string): boolean {
  const chA = extractChapterCode(codeA);
  const chB = extractChapterCode(codeB);
  return chA !== null && chB !== null && chA === chB;
}

// ============================================================
// Matching Logic
// ============================================================

/** Thresholds for description similarity matching */
const SIMILARITY_CONFIDENT = 0.65;
const SIMILARITY_POTENTIAL = 0.45;

interface MatchCandidate {
  boqItem: BoqItem;
  wbsArticle: WbsArticle;
  confidence: number;
  matchMethod: "code_exact" | "code_prefix" | "description" | "description_weak";
}

/**
 * Try to match a BOQ item code to a WBS article code.
 * Returns confidence: 1.0 for exact match, 0.9 for prefix match, 0 for no match.
 */
function codeMatch(boqCode: string, wbsCode: string): number {
  if (!boqCode || !wbsCode) return 0;

  const normalizedBoq = boqCode.trim().replace(/\s+/g, "");
  const normalizedWbs = wbsCode.trim().replace(/\s+/g, "");

  // Exact match
  if (normalizedBoq === normalizedWbs) return 1.0;

  // Prefix match: one code is a prefix of the other (e.g., "06.01" matches "06.01.003")
  if (normalizedBoq.startsWith(normalizedWbs) || normalizedWbs.startsWith(normalizedBoq)) {
    return 0.9;
  }

  return 0;
}

/**
 * Find the best match for a single WBS article among all BOQ items.
 * Returns null if no match meets the threshold.
 */
function findBestMatch(
  wbsArticle: WbsArticle,
  boqItems: BoqItem[],
  usedBoqIndices: Set<number>,
): MatchCandidate | null {
  let bestCandidate: MatchCandidate | null = null;
  let bestScore = 0;

  for (let i = 0; i < boqItems.length; i++) {
    if (usedBoqIndices.has(i)) continue;

    const boqItem = boqItems[i];

    // 1. Try code match
    const codeConf = codeMatch(boqItem.code, wbsArticle.code);
    if (codeConf > 0) {
      const score = codeConf;
      if (score > bestScore) {
        bestScore = score;
        bestCandidate = {
          boqItem,
          wbsArticle,
          confidence: score,
          matchMethod: codeConf === 1.0 ? "code_exact" : "code_prefix",
        };
      }
      continue; // Code match is definitive; do not downgrade with description
    }

    // 2. Try description similarity (optionally scoped by chapter)
    const inSameChapter = boqItem.code && wbsArticle.code
      ? sameChapter(boqItem.code, wbsArticle.code)
      : false;

    const sim = textSimilarity(boqItem.description, wbsArticle.description);

    // If same chapter, lower the effective threshold slightly
    const effectiveThreshold = inSameChapter
      ? SIMILARITY_POTENTIAL * 0.85
      : SIMILARITY_POTENTIAL;

    if (sim >= effectiveThreshold) {
      // Also factor in unit compatibility for confidence
      const unitBonus = unitsCompatible(boqItem.unit, wbsArticle.unit) ? 0.05 : 0;
      const chapterBonus = inSameChapter ? 0.05 : 0;
      const totalScore = Math.min(1, sim + unitBonus + chapterBonus);

      if (totalScore > bestScore) {
        bestScore = totalScore;
        bestCandidate = {
          boqItem,
          wbsArticle,
          confidence: totalScore,
          matchMethod: totalScore >= SIMILARITY_CONFIDENT ? "description" : "description_weak",
        };
      }
    }
  }

  return bestCandidate;
}

// ============================================================
// Cost Impact Helpers
// ============================================================

/**
 * Estimate the unit price for a WBS article that lacks one,
 * by looking at matched BOQ items or using a fallback.
 */
function estimateUnitPrice(wbsArticle: WbsArticle, boqItems: BoqItem[]): number {
  // If the WBS article already has a unit price, use it
  if (wbsArticle.unitPrice && wbsArticle.unitPrice > 0) {
    return wbsArticle.unitPrice;
  }

  // Try to find a BOQ item with a similar description for price reference
  for (const boq of boqItems) {
    if (
      unitsCompatible(boq.unit, wbsArticle.unit) &&
      textSimilarity(boq.description, wbsArticle.description) > SIMILARITY_POTENTIAL
    ) {
      return boq.unitPrice;
    }
  }

  // Fallback: generic per-unit estimate (conservative)
  const unit = normalizeUnit(wbsArticle.unit);
  const fallbacks: Record<string, number> = {
    m2: 35,
    m3: 120,
    m: 25,
    ud: 150,
    kg: 2,
    vg: 500,
    sistema: 2000,
    projeto: 3000,
    ensaio: 1500,
  };

  return fallbacks[unit] ?? 100;
}

// ============================================================
// Main Comparison Function
// ============================================================

/**
 * Compare an uploaded BOQ against generated WBS articles and
 * identify gaps, surpluses, and quantity mismatches.
 *
 * @param boq - Parsed BOQ from xlsx-parser
 * @param wbsArticles - WBS articles from project-extrapolator or manual WBS
 * @param findingArticles - Articles generated from findings-to-wbs (regulatory)
 * @returns Structured diff result
 */
export function compareBoqToWbs(
  boq: ParsedBoq,
  wbsArticles: WbsArticle[],
  findingArticles?: WbsArticle[],
): BoqDiffResult {
  const warnings: string[] = [];
  const items: DiffItem[] = [];

  // Merge all WBS articles, tagging finding articles as regulatory
  const findingCodes = new Set<string>(
    (findingArticles ?? []).map(a => a.code),
  );
  const allWbsArticles = [
    ...wbsArticles,
    ...(findingArticles ?? []).filter(fa =>
      !wbsArticles.some(wa => wa.code === fa.code),
    ),
  ];

  if (boq.items.length === 0) {
    warnings.push("O BOQ carregado não contém itens. Verifique o ficheiro Excel.");
  }
  if (allWbsArticles.length === 0) {
    warnings.push("Nenhum artigo WBS disponível para comparação.");
  }

  // Track which BOQ items have been matched
  const usedBoqIndices = new Set<number>();
  // Track which WBS articles have been matched
  const matchedWbsIndices = new Set<number>();

  // Phase 1: Match each WBS article to the best BOQ item
  for (let wIdx = 0; wIdx < allWbsArticles.length; wIdx++) {
    const wbsArticle = allWbsArticles[wIdx];
    const isRegulatory = findingCodes.has(wbsArticle.code);

    const match = findBestMatch(wbsArticle, boq.items, usedBoqIndices);

    if (match && match.confidence >= SIMILARITY_POTENTIAL) {
      const boqIndex = boq.items.indexOf(match.boqItem);
      usedBoqIndices.add(boqIndex);
      matchedWbsIndices.add(wIdx);

      const boqItem = match.boqItem;

      // Check unit compatibility
      if (!unitsCompatible(boqItem.unit, wbsArticle.unit)) {
        items.push({
          status: "unit_mismatch",
          description: wbsArticle.description,
          boqItem,
          wbsArticle,
          matchConfidence: match.confidence,
          recommendation: `Unidades incompatíveis: BOQ usa "${boqItem.unit}", WBS usa "${wbsArticle.unit}". Verificar e uniformizar as unidades de medição.`,
          isRegulatoryRequired: isRegulatory,
        });
        continue;
      }

      // Check quantity
      const qtyDelta = wbsArticle.quantity - boqItem.quantity;
      const qtyRatio = boqItem.quantity > 0
        ? Math.abs(qtyDelta) / boqItem.quantity
        : (wbsArticle.quantity > 0 ? 1 : 0);

      if (qtyRatio > 0.05) {
        // More than 5% difference = quantity mismatch
        const unitPrice = boqItem.unitPrice > 0
          ? boqItem.unitPrice
          : estimateUnitPrice(wbsArticle, boq.items);
        const costImpact = qtyDelta * unitPrice;

        const direction = qtyDelta > 0 ? "superior" : "inferior";
        const absQtyDelta = Math.abs(qtyDelta);

        items.push({
          status: "quantity_mismatch",
          description: wbsArticle.description,
          boqItem,
          wbsArticle,
          quantityDelta: qtyDelta,
          costImpact: Math.round(costImpact),
          matchConfidence: match.confidence,
          recommendation:
            `Quantidade no WBS (${wbsArticle.quantity} ${wbsArticle.unit}) ` +
            `${direction} ao BOQ (${boqItem.quantity} ${boqItem.unit}). ` +
            `Diferença: ${qtyDelta > 0 ? "+" : ""}${absQtyDelta.toFixed(2)} ${wbsArticle.unit}` +
            (Math.abs(costImpact) > 0
              ? ` — impacto estimado: ${formatEur(costImpact)}`
              : "."),
          isRegulatoryRequired: isRegulatory,
        });
      } else {
        // Matched within tolerance
        items.push({
          status: "matched",
          description: wbsArticle.description,
          boqItem,
          wbsArticle,
          quantityDelta: 0,
          costImpact: 0,
          matchConfidence: match.confidence,
          recommendation: "Artigo presente no BOQ com quantidade conforme.",
          isRegulatoryRequired: isRegulatory,
        });
      }
    } else {
      // No match found -> missing in BOQ
      const unitPrice = estimateUnitPrice(wbsArticle, boq.items);
      const estimatedCost = wbsArticle.quantity * unitPrice;

      const status: DiffStatus = isRegulatory ? "new_required" : "missing_in_boq";

      items.push({
        status,
        description: wbsArticle.description,
        wbsArticle,
        quantityDelta: wbsArticle.quantity,
        costImpact: Math.round(estimatedCost),
        matchConfidence: match?.confidence ?? 0,
        recommendation:
          status === "new_required"
            ? `Artigo regulamentar em falta. Adicionar ao mapa de quantidades: ${wbsArticle.description} — estimativa ${formatEur(estimatedCost)}.`
            : `Adicionar ao mapa de quantidades: ${wbsArticle.description} (${wbsArticle.quantity} ${wbsArticle.unit}) — estimativa ${formatEur(estimatedCost)}.`,
        isRegulatoryRequired: isRegulatory,
      });
    }
  }

  // Phase 2: Find BOQ items not matched to any WBS article (extra in BOQ)
  for (let i = 0; i < boq.items.length; i++) {
    if (usedBoqIndices.has(i)) continue;

    const boqItem = boq.items[i];
    items.push({
      status: "missing_in_wbs",
      description: boqItem.description,
      boqItem,
      costImpact: boqItem.totalPrice,
      matchConfidence: 0,
      recommendation:
        `Artigo presente no BOQ mas sem correspondência no WBS gerado. ` +
        `Verificar se "${boqItem.description}" é necessário ou pode ser removido.`,
      isRegulatoryRequired: false,
    });
  }

  // Build categorized lists
  const missingInBoq = items.filter(
    i => i.status === "missing_in_boq" || i.status === "new_required",
  );
  const extraInBoq = items.filter(i => i.status === "missing_in_wbs");
  const quantityMismatches = items.filter(
    i => i.status === "quantity_mismatch" || i.status === "unit_mismatch",
  );
  const matched = items.filter(i => i.status === "matched");

  // Compute summary
  const missingCostEstimate = missingInBoq.reduce(
    (sum, item) => sum + (item.costImpact ?? 0),
    0,
  );
  const boqTotalCost = boq.totalCost;
  const estimatedTotalCost = boqTotalCost + missingCostEstimate;

  const totalMatchable = matched.length + quantityMismatches.length + missingInBoq.length;
  const completenessPercent =
    totalMatchable > 0
      ? Math.round(((matched.length + quantityMismatches.length) / totalMatchable) * 100)
      : 0;

  // Generate warnings
  if (missingInBoq.length > 0) {
    const regulatoryMissing = missingInBoq.filter(i => i.isRegulatoryRequired);
    if (regulatoryMissing.length > 0) {
      warnings.push(
        `${regulatoryMissing.length} artigo(s) regulamentar(es) em falta no BOQ. ` +
        `Estes são obrigatórios para conformidade.`,
      );
    }
  }

  if (completenessPercent < 50) {
    warnings.push(
      `O BOQ cobre apenas ${completenessPercent}% dos artigos identificados. ` +
      `Considere uma revisão completa do mapa de quantidades.`,
    );
  }

  if (extraInBoq.length > allWbsArticles.length * 0.5 && allWbsArticles.length > 0) {
    warnings.push(
      `${extraInBoq.length} artigos no BOQ sem correspondência no WBS. ` +
      `A estrutura do BOQ pode diferir significativamente do WBS gerado.`,
    );
  }

  const mismatchCostImpact = quantityMismatches.reduce(
    (sum, item) => sum + Math.abs(item.costImpact ?? 0),
    0,
  );
  if (mismatchCostImpact > boqTotalCost * 0.1 && boqTotalCost > 0) {
    warnings.push(
      `As diferenças de quantidade representam um impacto de ${formatEur(mismatchCostImpact)} ` +
      `(${((mismatchCostImpact / boqTotalCost) * 100).toFixed(1)}% do custo do BOQ).`,
    );
  }

  return {
    items,
    missingInBoq,
    extraInBoq,
    quantityMismatches,
    matched,
    summary: {
      totalBoqItems: boq.items.length,
      totalWbsItems: allWbsArticles.length,
      matchedCount: matched.length,
      missingCount: missingInBoq.length,
      extraCount: extraInBoq.length,
      mismatchCount: quantityMismatches.length,
      missingCostEstimate: Math.round(missingCostEstimate),
      boqTotalCost: Math.round(boqTotalCost),
      estimatedTotalCost: Math.round(estimatedTotalCost),
      completenessPercent,
    },
    boqUsesIsoWbs: boq.isIsoWbs,
    warnings,
  };
}

// ============================================================
// Report Formatting
// ============================================================

/**
 * Format a EUR value for display in Portuguese locale.
 */
function formatEur(value: number): string {
  const abs = Math.abs(value);
  const formatted = new Intl.NumberFormat("pt-PT", {
    style: "currency",
    currency: "EUR",
    minimumFractionDigits: 0,
    maximumFractionDigits: 0,
  }).format(abs);
  return value < 0 ? `-${formatted}` : formatted;
}

/**
 * Generate a Portuguese text report summarizing the BOQ vs WBS comparison.
 */
export function formatDiffReport(result: BoqDiffResult): string {
  const lines: string[] = [];
  const s = result.summary;

  // Header
  lines.push("╔══════════════════════════════════════════════════════════════╗");
  lines.push("║        RELATÓRIO DE COMPARAÇÃO BOQ vs. WBS                 ║");
  lines.push("╚══════════════════════════════════════════════════════════════╝");
  lines.push("");

  // Summary
  lines.push("── RESUMO ─────────────────────────────────────────────────────");
  lines.push(`  Artigos no BOQ carregado:      ${s.totalBoqItems}`);
  lines.push(`  Artigos no WBS gerado:         ${s.totalWbsItems}`);
  lines.push(`  Artigos correspondidos:        ${s.matchedCount}`);
  lines.push(`  Artigos em falta no BOQ:       ${s.missingCount}`);
  lines.push(`  Artigos extra no BOQ:          ${s.extraCount}`);
  lines.push(`  Divergências de quantidade:    ${s.mismatchCount}`);
  lines.push(`  Completude do BOQ:             ${s.completenessPercent}%`);
  lines.push("");
  lines.push(`  Custo total do BOQ:            ${formatEur(s.boqTotalCost)}`);
  lines.push(`  Custo estimado em falta:       ${formatEur(s.missingCostEstimate)}`);
  lines.push(`  Custo total estimado projeto:  ${formatEur(s.estimatedTotalCost)}`);

  if (result.boqUsesIsoWbs) {
    lines.push("");
    lines.push("  O BOQ segue a estrutura ISO 12006-2 / ProNIC.");
  }

  // Warnings
  if (result.warnings.length > 0) {
    lines.push("");
    lines.push("── AVISOS ─────────────────────────────────────────────────────");
    for (const w of result.warnings) {
      lines.push(`  ⚠ ${w}`);
    }
  }

  // Missing in BOQ (most critical section)
  if (result.missingInBoq.length > 0) {
    lines.push("");
    lines.push("── ARTIGOS EM FALTA NO BOQ ────────────────────────────────────");
    lines.push("  Estes artigos devem ser adicionados ao mapa de quantidades:");
    lines.push("");

    const regulatory = result.missingInBoq.filter(i => i.isRegulatoryRequired);
    const nonRegulatory = result.missingInBoq.filter(i => !i.isRegulatoryRequired);

    if (regulatory.length > 0) {
      lines.push("  [OBRIGATÓRIOS — requisitos regulamentares]");
      for (const item of regulatory) {
        const code = item.wbsArticle?.code ?? "—";
        const qty = item.wbsArticle
          ? `${item.wbsArticle.quantity} ${item.wbsArticle.unit}`
          : "—";
        lines.push(`    ${code}  ${item.description}`);
        lines.push(`           Qtd: ${qty}  |  Custo estimado: ${formatEur(item.costImpact ?? 0)}`);
      }
      lines.push("");
    }

    if (nonRegulatory.length > 0) {
      lines.push("  [RECOMENDADOS — baseados na análise do projeto]");
      for (const item of nonRegulatory) {
        const code = item.wbsArticle?.code ?? "—";
        const qty = item.wbsArticle
          ? `${item.wbsArticle.quantity} ${item.wbsArticle.unit}`
          : "—";
        lines.push(`    ${code}  ${item.description}`);
        lines.push(`           Qtd: ${qty}  |  Custo estimado: ${formatEur(item.costImpact ?? 0)}`);
      }
    }
  }

  // Quantity mismatches
  if (result.quantityMismatches.length > 0) {
    lines.push("");
    lines.push("── DIVERGÊNCIAS DE QUANTIDADE ─────────────────────────────────");

    for (const item of result.quantityMismatches) {
      if (item.status === "unit_mismatch") {
        lines.push(
          `  ${item.wbsArticle?.code ?? "—"}  ${item.description}`,
        );
        lines.push(
          `           BOQ: ${item.boqItem?.unit ?? "?"} vs WBS: ${item.wbsArticle?.unit ?? "?"}  |  Unidades incompatíveis`,
        );
      } else {
        const boqQty = item.boqItem?.quantity ?? 0;
        const wbsQty = item.wbsArticle?.quantity ?? 0;
        const unit = item.wbsArticle?.unit ?? item.boqItem?.unit ?? "";
        const delta = item.quantityDelta ?? 0;

        lines.push(
          `  ${item.wbsArticle?.code ?? item.boqItem?.code ?? "—"}  ${item.description}`,
        );
        lines.push(
          `           BOQ: ${boqQty} ${unit}  →  WBS: ${wbsQty} ${unit}  ` +
          `(${delta > 0 ? "+" : ""}${delta.toFixed(2)} ${unit})  |  ` +
          `Impacto: ${formatEur(item.costImpact ?? 0)}`,
        );
      }
    }
  }

  // Extra in BOQ
  if (result.extraInBoq.length > 0) {
    lines.push("");
    lines.push("── ARTIGOS EXTRA NO BOQ ───────────────────────────────────────");
    lines.push("  Presentes no BOQ mas sem correspondência no WBS:");
    lines.push("");

    for (const item of result.extraInBoq) {
      const code = item.boqItem?.code ?? "—";
      const qty = item.boqItem
        ? `${item.boqItem.quantity} ${item.boqItem.unit}`
        : "—";
      const cost = item.boqItem?.totalPrice ?? 0;
      lines.push(`    ${code}  ${item.description}`);
      lines.push(`           Qtd: ${qty}  |  Custo: ${formatEur(cost)}`);
    }
  }

  // Matched items (brief summary)
  if (result.matched.length > 0) {
    lines.push("");
    lines.push("── ARTIGOS CORRESPONDIDOS ─────────────────────────────────────");

    for (const item of result.matched) {
      const code = item.wbsArticle?.code ?? item.boqItem?.code ?? "—";
      const confidence = Math.round(item.matchConfidence * 100);
      lines.push(`    ${code}  ${item.description}  [${confidence}%]`);
    }
  }

  // Footer
  lines.push("");
  lines.push("────────────────────────────────────────────────────────────────");
  lines.push(
    `Relatório gerado em ${new Date().toLocaleDateString("pt-PT")} ` +
    `às ${new Date().toLocaleTimeString("pt-PT")}.`,
  );
  lines.push(
    "Nota: Os custos estimados são indicativos e baseados em referências CYPE.",
  );
  lines.push(
    "Consulte geradordeprecos.info para orçamentação definitiva.",
  );

  return lines.join("\n");
}
